{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-assert-injector.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-connect.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-signal-slice.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.2.4\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  constructor(source) {\n    this.source = source;\n    this.destroyed = false;\n    this.destroyRef = inject(DestroyRef);\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n", "import { assertInInjectionContext, inject, Injector, runInInjectionContext } from '@angular/core';\nfunction assertInjector(fn, injector, runner) {\n  !injector && assertInInjectionContext(fn);\n  const assertedInjector = injector ?? inject(Injector);\n  if (!runner) return assertedInjector;\n  return runInInjectionContext(assertedInjector, runner);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { assertInjector };\n", "import { DestroyRef, untracked, Injector, effect } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport { Subscription, isObservable } from 'rxjs';\nfunction connect(signal, ...args) {\n  const [observable, reducer, injectorOrDestroyRef, useUntracked, originSignal] = parseArgs(args);\n  if (observable) {\n    let destroyRef = null;\n    if (injectorOrDestroyRef instanceof DestroyRef) {\n      destroyRef = injectorOrDestroyRef; // if it's a DestroyRef, use it\n    } else {\n      const injector = assertInjector(connect, injectorOrDestroyRef);\n      destroyRef = injector.get(DestroyRef);\n    }\n    return observable.pipe(takeUntilDestroyed(destroyRef)).subscribe(x => {\n      const update = () => {\n        signal.update(prev => {\n          if (!isObject(prev)) {\n            return reducer?.(prev, x) || x;\n          }\n          if (!isObject(x)) {\n            const reducedValue = reducer ? reducer(prev, x) : x;\n            return isObject(reducedValue) ? {\n              ...prev,\n              ...reducedValue\n            } : reducedValue;\n          }\n          return {\n            ...prev,\n            ...(reducer?.(prev, x) || x)\n          };\n        });\n      };\n      if (useUntracked) {\n        untracked(update);\n      } else {\n        update();\n      }\n    });\n  }\n  if (originSignal) {\n    const injector = injectorOrDestroyRef instanceof Injector ? assertInjector(connect, injectorOrDestroyRef) : undefined;\n    return effect(() => {\n      signal.update(prev => {\n        if (!isObject(prev)) {\n          return originSignal();\n        }\n        return {\n          ...prev,\n          ...originSignal()\n        };\n      });\n    }, {\n      allowSignalWrites: true,\n      injector\n    });\n  }\n  return {\n    with(...args) {\n      if (!this.subscription) {\n        this.subscription = new Subscription();\n      } else if (this.subscription.closed) {\n        console.info(`[ngxtension connect] ConnectedSignal has been closed.`);\n        return this;\n      }\n      this.subscription.add(connect(signal, ...args, injectorOrDestroyRef, useUntracked));\n      return this;\n    },\n    subscription: null\n  };\n}\n// TODO: there must be a way to parse the args more efficiently\nfunction parseArgs(args) {\n  if (args.length > 3) {\n    return [args[0], args[1], args[2], args[3], null];\n  }\n  if (args.length === 3) {\n    if (typeof args[2] === 'boolean') {\n      if (isObservable(args[0])) {\n        return [args[0], null, args[1], args[2], null];\n      } else {\n        return [null, null, args[1], args[2], args[0]];\n      }\n    }\n    return [args[0], args[1], args[2], false, null];\n  }\n  if (args.length === 2) {\n    if (typeof args[1] === 'boolean') {\n      return [null, null, args[0], args[1], null];\n    }\n    if (typeof args[1] === 'function') {\n      return [args[0], args[1], null, false, null];\n    }\n    return [args[0], null, args[1], false, null];\n  }\n  if (isObservable(args[0])) {\n    return [args[0], null, null, false, null];\n  }\n  // to connect signals to other signals, we need to use a callback that includes a signal call\n  if (typeof args[0] === 'function') {\n    return [null, null, null, false, args[0]];\n  }\n  return [null, null, args[0], false, null];\n}\nfunction isObject(val) {\n  return typeof val === 'object' && val !== undefined && val !== null && !Array.isArray(val);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { connect };\n", "import { inject, DestroyRef, Injector, signal, computed, effect } from '@angular/core';\nimport { toObservable, takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { connect } from 'ngxtension/connect';\nimport { isObservable, Subject, share, take } from 'rxjs';\nfunction signalSlice(config) {\n  const destroyRef = inject(DestroyRef);\n  const injector = inject(Injector);\n  const {\n    initialState,\n    sources = [],\n    lazySources = [],\n    actionSources = {},\n    selectors = () => ({}),\n    effects = () => ({})\n  } = config;\n  const state = signal(initialState);\n  const readonlyState = state.asReadonly();\n  const state$ = toObservable(state);\n  let lazySourcesLoaded = false;\n  const subs = [];\n  const slice = readonlyState;\n  connectSources(state, sources);\n  for (const [key, actionSource] of Object.entries(actionSources)) {\n    if (isObservable(actionSource)) {\n      addReducerProperties(readonlyState, state$, key, destroyRef, actionSource, subs);\n    } else {\n      const subject = new Subject();\n      const observable = actionSource(readonlyState, subject);\n      const sharedObservable = observable.pipe(share());\n      connect(state, sharedObservable);\n      addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, sharedObservable);\n    }\n  }\n  for (const key in initialState) {\n    Object.defineProperty(readonlyState, key, {\n      value: computed(() => readonlyState()[key])\n    });\n  }\n  for (const [key, selector] of Object.entries(selectors(slice))) {\n    Object.defineProperty(readonlyState, key, {\n      value: computed(selector)\n    });\n  }\n  for (const [key, namedEffect] of Object.entries(effects(slice))) {\n    console.warn(\"The 'effects' configuration in signalSlice is deprecated. Please use standard signal effects outside of signalSlice instead.\");\n    Object.defineProperty(slice, key, {\n      value: effect(onCleanup => {\n        const maybeCleanup = namedEffect();\n        if (maybeCleanup) {\n          onCleanup(() => maybeCleanup());\n        }\n      })\n    });\n  }\n  destroyRef.onDestroy(() => {\n    subs.forEach(sub => sub.complete());\n  });\n  const connectLazySources = () => {\n    if (!lazySourcesLoaded) {\n      lazySourcesLoaded = true;\n      connectSources(state, lazySources, injector, true);\n    }\n  };\n  return new Proxy(slice, {\n    get(target, property, receiver) {\n      connectLazySources();\n      return Reflect.get(target, property, receiver);\n    },\n    apply(target, thisArg, argumentsList) {\n      connectLazySources();\n      return Reflect.apply(target, thisArg, argumentsList);\n    }\n  });\n}\nfunction connectSources(state, sources, injector, useUntracked = false) {\n  for (const source of sources) {\n    if (isObservable(source)) {\n      connect(state, source, injector, useUntracked);\n    } else {\n      connect(state, source(state.asReadonly()), injector, useUntracked);\n    }\n  }\n}\nfunction addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, observableFromActionSource) {\n  Object.defineProperties(readonlyState, {\n    [key]: {\n      value: nextValue => {\n        if (isObservable(nextValue)) {\n          return new Promise((res, rej) => {\n            nextValue.pipe(takeUntilDestroyed(destroyRef)).subscribe({\n              next: value => {\n                subject.next(value);\n              },\n              error: err => {\n                subject.error(err);\n                rej(err);\n              },\n              complete: () => {\n                subject.complete();\n                res(readonlyState());\n              }\n            });\n          });\n        }\n        if (observableFromActionSource) {\n          observableFromActionSource.pipe(takeUntilDestroyed(destroyRef)).subscribe();\n        }\n        return new Promise(res => {\n          state$.pipe(take(1)).subscribe(val => {\n            res(val);\n          });\n          subject.next(nextValue);\n        });\n      }\n    },\n    [`${key}$`]: {\n      value: subject.asObservable()\n    }\n  });\n  subs.push(subject);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { signalSlice };\n"],
  "mappings": "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",
  "names": ["signal", "args"]
}
